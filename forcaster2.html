<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 6c3 0 4-3 6-3s3 3 6 3 4-3 6-3' /%3E%3Cpath d='M3 12c3 0 4-3 6-3s3 3 6 3 4-3 6-3' /%3E%3Cpath d='M3 18c3 0 4-3 6-3s3 3 6 3 4-3 6-3' /%3E%3C/svg%3E" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Surf Forecast</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react": "https://esm.sh/react@18.2.0"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback } from 'react';
      import ReactDOM from 'react-dom/client';

      // --- TYPES (as JS objects) ---
      const Rating = {
        FLAT: 'שטוח',
        VERY_POOR: 'נמוך מאוד',
        POOR: 'נמוך',
        POOR_TO_FAIR: 'בינוני-נמוך',
        FAIR: 'בינוני',
        FAIR_TO_GOOD: 'בינוני-טוב',
        GOOD: 'טוב',
      };
      
      // --- ICONS ---
      const WaveIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M3 6c3 0 4-3 6-3s3 3 6 3 4-3 6-3" /><path d="M3 12c3 0 4-3 6-3s3 3 6 3 4-3 6-3" /><path d="M3 18c3 0 4-3 6-3s3 3 6 3 4-3 6-3" />
        </svg>
      );
      const SunIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <circle cx="12" cy="12" r="5" /><line x1="12" y1="1" x2="12" y2="3" /><line x1="12" y1="21" x2="12" y2="23" /><line x1="4.22" y1="4.22" x2="5.64" y2="5.64" /><line x1="18.36" y1="18.36" x2="19.78" y2="19.78" /><line x1="1" y1="12" x2="3" y2="12" /><line x1="21" y1="12" x2="23" y2="12" /><line x1="4.22" y1="19.78" x2="5.64" y2="18.36" /><line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
        </svg>
      );
      const MoonIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
        </svg>
      );
      const WindIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/>
        </svg>
      );
      const SwellIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M3 6c3 0 4 3 6 3s3-3 6-3 4 3 6 3"/><path d="M3 12c3 0 4 3 6 3s3-3 6-3 4 3 6 3"/>
        </svg>
      );
      const DirectionArrowIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" {...props}>
          <path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
        </svg>
      );

      // --- COMPONENTS ---
      const ForecastChart = ({ conditions, units }) => {
        const chartData = conditions.flatMap(c => ([
          {
            timestamp: c.timestamp,
            period: 'am',
            day: new Date(c.timestamp * 1000).toLocaleDateString('he-IL', { weekday: 'long', timeZone: 'Asia/Jerusalem' }),
            label: `${new Date(c.timestamp * 1000).toLocaleDateString('he-IL', { weekday: 'short', timeZone: 'Asia/Jerusalem' })} בוקר`,
            height: c.am.maxHeight,
          },
          {
            timestamp: c.timestamp,
            period: 'pm',
            day: new Date(c.timestamp * 1000).toLocaleDateString('he-IL', { weekday: 'long', timeZone: 'Asia/Jerusalem' }),
            label: `${new Date(c.timestamp * 1000).toLocaleDateString('he-IL', { weekday: 'short', timeZone: 'Asia/Jerusalem' })} ערב`,
            height: c.pm.maxHeight,
          }
        ]));

        const createSmoothPath = (points) => {
          if (points.length < 2) return "";
          let path = `M ${points[0][0]} ${points[0][1]}`;
          for (let i = 0; i < points.length - 1; i++) {
            const p0 = points[i - 1] || points[i];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = points[i + 2] || p2;
            const tension = 0.5;
            const cp1x = p1[0] + (p2[0] - p0[0]) / 6 * tension;
            const cp1y = p1[1] + (p2[1] - p0[1]) / 6 * tension;
            const cp2x = p2[0] - (p3[0] - p1[0]) / 6 * tension;
            const cp2y = p2[1] - (p3[1] - p1[1]) / 6 * tension;
            path += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${p2[0]},${p2[1]}`;
          }
          return path;
        };

        const allHeights = chartData.map(d => d.height).filter(h => h !== undefined && h !== null);
        if (allHeights.length === 0) return null;
        
        const maxHeight = Math.max(1, Math.ceil(Math.max(...allHeights) * 1.2));
        const svgWidth = 600;
        const svgHeight = 250;
        const padding = { top: 20, right: 40, bottom: 60, left: 20 };
        const chartWidth = svgWidth - padding.left - padding.right;
        const chartHeight = svgHeight - padding.top - padding.bottom;

        const getPoint = (height, index) => {
            const x = (svgWidth - padding.right) - (chartWidth / (chartData.length - 1)) * index;
            const y = chartHeight - (height / maxHeight) * chartHeight + padding.top;
            return [x, y];
        };

        const linePoints = chartData.map((data, index) => getPoint(data.height, index));
        const linePath = createSmoothPath(linePoints);

        const yAxisLabels = Array.from({ length: 5 }, (_, i) => {
            const value = (maxHeight / 4) * i;
            return {
                value: value.toFixed(1),
                y: chartHeight - (value / maxHeight) * chartHeight + padding.top,
            };
        });

        return (
          <div className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg p-4 sm:p-6 w-full">
            <h3 className="text-xl font-bold text-slate-700 mb-4 text-center">תחזית גובה גלים (5 ימים)</h3>
            <div className="w-full overflow-x-auto">
              <svg viewBox={`0 0 ${svgWidth} ${svgHeight}`} className="min-w-[600px]">
                <g className="y-axis-grid">
                  {yAxisLabels.map(label => (
                    <g key={label.value}>
                      <line x1={padding.left} y1={label.y} x2={svgWidth - padding.right} y2={label.y} stroke="#e2e8f0" strokeWidth="1" strokeDasharray="3,3" />
                      <text x={svgWidth - padding.right + 8} y={label.y + 4} textAnchor="start" fill="#64748b" className="text-xs">{label.value}{units.waveHeight}</text>
                    </g>
                  ))}
                </g>
                <g className="line">
                  <path d={linePath} fill="none" stroke="#0891b2" strokeWidth="3.5" strokeLinecap="round" strokeLinejoin="round" style={{filter: 'drop-shadow(0 2px 2px rgba(0,0,0,0.1))'}} />
                </g>
                <g className="points">
                  {linePoints.map((point, index) => (
                    <circle key={`point-${index}`} cx={point[0]} cy={point[1]} r="5" fill="#0891b2" stroke="white" strokeWidth="2" className="transition-transform duration-200 ease-in-out hover:scale-125">
                      <title>{chartData[index].label}: {chartData[index].height}{units.waveHeight}</title>
                    </circle>
                  ))}
                </g>
                <g className="x-axis">
                   {chartData.map((data, index) => {
                      const xPos = (svgWidth - padding.right) - (chartWidth / (chartData.length - 1)) * index;
                      const yPos = svgHeight - padding.bottom + 15;
                      const periodLabel = data.period === 'am' ? 'בוקר' : 'ערב';
                      const isFirstPeriodOfDay = index % 2 === 0;

                      return (
                        <g key={`label-group-${index}`}>
                          <text x={xPos} y={yPos} textAnchor="middle" fill="#64748b" className="text-xs font-semibold">
                            {periodLabel}
                          </text>
                          {isFirstPeriodOfDay && (
                             <text x={xPos - (chartWidth / (chartData.length -1) / 2)} y={yPos + 16} textAnchor="middle" fill="#94a3b8" className="text-[10px] font-bold">
                                {data.day}
                            </text>
                          )}
                        </g>
                      );
                  })}
                </g>
                <line x1={padding.left} y1={svgHeight - padding.bottom} x2={svgWidth - padding.right} y2={svgHeight - padding.bottom} stroke="#94a3b8" strokeWidth="1" />
              </svg>
            </div>
          </div>
        );
      };

      const ForecastCard = ({ condition, units, style }) => {
        const getRatingColor = (ratingKey) => {
          const ratingText = Rating[ratingKey] || ratingKey;
          switch (ratingText) {
            case Rating.GOOD: case Rating.FAIR_TO_GOOD: return 'bg-green-500';
            case Rating.FAIR: case Rating.POOR_TO_FAIR: return 'bg-yellow-500';
            case Rating.POOR: case Rating.VERY_POOR: return 'bg-red-500';
            case Rating.FLAT: return 'bg-gray-500';
            default: return 'bg-gray-400';
          }
        };

        const WindRelationTag = ({ relation }) => {
          const styles = { 'Offshore': 'bg-green-100 text-green-800', 'Onshore': 'bg-red-100 text-red-800', 'Cross-shore': 'bg-yellow-100 text-yellow-800' };
          const text = { 'Offshore': 'אופשור', 'Onshore': 'אונשור', 'Cross-shore': 'צד' };
          return <span className={`px-2 py-0.5 text-xs font-semibold rounded-full ${styles[relation]}`}>{text[relation] || relation}</span>;
        };

        const PeriodForecast = ({ period, data, units }) => {
          if (!data) return null;
          const ratingColor = getRatingColor(data.rating);
          const primarySwell = data.swell && data.swell.length > 0 ? data.swell[0] : null;
          return (
            <div className="flex-1 p-4 rounded-lg bg-white/50 flex flex-col">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-bold text-lg">{period === 'am' ? 'בוקר' : 'ערב'}</h4>
                {period === 'am' ? <SunIcon className="w-6 h-6 text-amber-500" /> : <MoonIcon className="w-6 h-6 text-indigo-500" />}
              </div>
              <div className="text-center my-3">
                <p className="text-3xl font-bold text-cyan-700">{data.minHeight}-{data.maxHeight}<span className="text-xl font-normal ml-1">{units.waveHeight}</span></p>
                <p className="text-sm text-slate-600">{data.humanRelation}</p>
              </div>
              <div className={`text-center p-1.5 rounded-full text-white text-sm font-semibold ${ratingColor} mb-4`}>{Rating[data.rating] || data.rating || 'אין דירוג'}</div>
              <div className="mt-auto pt-3 border-t border-slate-200 space-y-2 text-sm">
                {primarySwell && (
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2 text-slate-600"><SwellIcon className="w-5 h-5" /><span>גל</span></div>
                    <div className="flex items-center gap-2 font-semibold text-slate-800">
                      <span>{primarySwell.height}{units.swellHeight} @ {primarySwell.period}s</span>
                      <DirectionArrowIcon className="w-4 h-4 text-slate-500 transition-transform duration-500" style={{ transform: `rotate(${primarySwell.direction}deg)` }}/>
                    </div>
                  </div>
                )}
                {data.wind && <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2 text-slate-600"><WindIcon className="w-5 h-5" /><span>רוח</span></div>
                  <div className="flex items-center gap-2 font-semibold text-slate-800">
                    <WindRelationTag relation={data.wind.relation} />
                    <span>{data.wind.speed} {units.windSpeed}</span>
                    <DirectionArrowIcon className="w-4 h-4 text-slate-500 transition-transform duration-500" style={{ transform: `rotate(${data.wind.direction}deg)` }}/>
                  </div>
                </div>}
              </div>
            </div>
          );
        };

        const date = new Date(condition.timestamp * 1000);
        const formattedDate = date.toLocaleDateString('he-IL', { weekday: 'long', day: 'numeric', month: 'long', timeZone: 'Asia/Jerusalem' });

        return (
          <div className="bg-white/80 backdrop-blur-md rounded-2xl shadow-lg p-5 transform transition-all duration-500 hover:scale-105 hover:shadow-2xl flex flex-col animate-fade-in-up" style={style}>
            <header className="text-center border-b border-slate-300 pb-3 mb-4">
              <h3 className="text-xl font-bold text-slate-700">{formattedDate.split(',')[0]}</h3>
              <p className="text-md text-slate-500">{formattedDate.split(',').slice(1).join(',')}</p>
            </header>
            <div className="flex-grow flex flex-col gap-4">
              <PeriodForecast period="am" data={condition.am} units={units} />
              <PeriodForecast period="pm" data={condition.pm} units={units} />
            </div>
            {condition.dayToWatch && (
              <div className="mt-4 p-2 bg-blue-100 text-blue-800 text-center rounded-lg font-semibold text-sm">⭐ יום לגלישה! {condition.headline}</div>
            )}
          </div>
        );
      };

      // --- APP COMPONENT ---
      const App = () => {
        const [forecastData, setForecastData] = useState(null);
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);

        const handleShowForecast = useCallback(async () => {
          setIsLoading(true);
          setError(null);

          const spotId = '584204204e65fad6a770913b';
          const subregionId = '58581a836630e24c448790b0';
          
          const conditionsUrl = `https://services.surfline.com/kbyg/regions/forecasts/conditions?subregionId=${subregionId}&days=5`;
          const swellsUrl = `https://services.surfline.com/kbyg/spots/forecasts/swells?spotId=${spotId}&days=5&intervalHours=1&units[swellHeight]=M&cacheEnabled=true`;

          try {
            const [conditionsRes, swellsRes] = await Promise.all([
              fetch(conditionsUrl),
              fetch(swellsUrl)
            ]);

            if (!conditionsRes.ok || !swellsRes.ok) {
              throw new Error('Network response was not ok');
            }

            const conditionsData = await conditionsRes.json();
            const swellsData = await swellsRes.json();
            
            const swellLookup = (swellsData?.data?.swells || []).reduce((acc, hourlySwell) => {
              acc[hourlySwell.timestamp] = hourlySwell.swells;
              return acc;
            }, {});

            const findClosestSwell = (targetTimestamp) => {
              const timestamps = Object.keys(swellLookup);
              if (timestamps.length === 0) return [];
              const closestTimestamp = timestamps.reduce((prev, curr) => 
                Math.abs(curr - targetTimestamp) < Math.abs(prev - targetTimestamp) ? curr : prev
              );
              return swellLookup[closestTimestamp] || [];
            };

            const processedConditions = (conditionsData?.data?.conditions || [])
              .filter(day => day.spotId === spotId || !day.spotId) // Filter for the specific spot if spotId is present, or assume it's for the main spot
              .map(day => {
                const amTimestamp = day.timestamp + 8 * 3600; // 8am local time
                const pmTimestamp = day.timestamp + 16 * 3600; // 4pm local time
                
                const newAm = day.am ? { ...day.am, swell: findClosestSwell(amTimestamp) } : { swell: findClosestSwell(amTimestamp) };
                const newPm = day.pm ? { ...day.pm, swell: findClosestSwell(pmTimestamp) } : { swell: findClosestSwell(pmTimestamp) };

                return { ...day, am: newAm, pm: newPm };
              });
            
            const finalData = {
              associated: conditionsData.associated || swellsData.associated,
              data: {
                conditions: processedConditions
              }
            };
            
            setForecastData(finalData);

          } catch (err) {
            console.error('Failed to fetch surf forecast:', err);
            setError('לא ניתן היה להביא את התחזית. נסה שוב מאוחר יותר.');
          } finally {
            setIsLoading(false);
          }
        }, []);

        const styleElement = document.getElementById('animation-styles');
        if (!styleElement) {
          const newStyleElement = document.createElement('style');
          newStyleElement.id = 'animation-styles';
          newStyleElement.innerHTML = `
            @keyframes fade-in-up { 0% { opacity: 0; transform: translateY(20px); } 100% { opacity: 1; transform: translateY(0); } }
            .animate-fade-in-up { animation: fade-in-up 0.5s ease-out forwards; opacity: 0; }
          `;
          document.head.appendChild(newStyleElement);
        }

        return (
          <div className="min-h-screen bg-gradient-to-br from-cyan-400 to-blue-600 font-sans text-slate-800 p-4 sm:p-6 lg:p-8">
            <div className="max-w-7xl mx-auto flex flex-col items-center">
              <header className="text-center text-white mb-8">
                <div className="flex justify-center items-center gap-4 mb-2">
                  <WaveIcon className="w-12 h-12" />
                  <h1 className="text-4xl sm:text-5xl font-bold tracking-tight">תחזית גלים</h1>
                </div>
                <p className="text-lg sm:text-xl font-light text-blue-100">חוף תל ברוך, תל אביב</p>
              </header>

              {!forecastData && !error && (
                <div className="text-center">
                  <button onClick={handleShowForecast} disabled={isLoading} className="px-8 py-4 bg-amber-500 text-white font-bold text-xl rounded-full shadow-lg hover:bg-amber-600 focus:outline-none focus:ring-4 focus:ring-amber-300 transition-all duration-300 ease-in-out transform hover:scale-105 disabled:bg-amber-300 disabled:cursor-not-allowed">
                    {isLoading ? (
                      <div className="flex items-center justify-center">
                        <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        טוען...
                      </div>
                    ) : 'הצג תחזית לחמישה ימים'}
                  </button>
                </div>
              )}
              
              {error && (
                <div className="text-center bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg animate-fade-in-up" role="alert">
                  <strong className="font-bold">אופס!</strong>
                  <span className="block sm:inline ml-2">{error}</span>
                </div>
              )}

              {forecastData && (
                <>
                  <section className="w-full mb-8 animate-fade-in-up">
                    <ForecastChart conditions={forecastData.data.conditions} units={forecastData.associated.units} />
                  </section>
                  <main className="w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-6">
                    {forecastData.data.conditions.map((condition, index) => (
                      <ForecastCard key={condition.timestamp} condition={condition} units={forecastData.associated.units} style={{ animationDelay: `${index * 100}ms` }}/>
                    ))}
                  </main>
                </>
              )}
            </div>
            <footer className="text-center text-white text-opacity-70 mt-12">
              <p>מופעל על ידי נתוני Surfline</p>
            </footer>
          </div>
        );
      };

      // --- RENDER APP ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
</body>
</html>